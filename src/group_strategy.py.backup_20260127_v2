"""
å››ç¾¤åˆ†å€ç­–ç•¥å¼•æ“
å°‡ 1-39 è™Ÿç¢¼åˆ†ç‚ºå››ç¾¤,å„è‡ªç¨ç«‹åˆ†æå¾Œå†è·¨ç¾¤ç¯©é¸
"""
import numpy as np
import pandas as pd
from src.models import FeatureEngine
from src.logger import logger

class GroupBasedStrategy:
    """å››ç¾¤åˆ†å€ç­–ç•¥å¼•æ“"""
    
    # å®šç¾©å››å€‹ç¾¤çµ„
    GROUPS = {
        'group1': (1, 10),
        'group2': (11, 20),
        'group3': (21, 30),
        'group4': (31, 39)
    }
    
    def __init__(self):
        # åˆå§‹åŒ–å„ç¾¤çµ„çš„æ¨¡å‹æ¬Šé‡ (å„ªåŒ–å¾Œ)
        self.group_weights = {
            'group1': {
                'freq': 1.2, 'rsi': 0.8, 'slope': 1.0, 'knn': 0.9,
                'svm': 1.1, 'markov': 1.3, 'pca': 0.7,
                'xgboost': 1.5, 'random_forest': 1.4, 'llm': 0.5
            },
            'group2': {
                'freq': 1.2, 'rsi': 0.8, 'slope': 1.0, 'knn': 0.9,
                'svm': 1.1, 'markov': 1.3, 'pca': 0.7,
                'xgboost': 1.5, 'random_forest': 1.4, 'llm': 0.5
            },
            'group3': {
                'freq': 1.2, 'rsi': 0.8, 'slope': 1.0, 'knn': 0.9,
                'svm': 1.1, 'markov': 1.3, 'pca': 0.7,
                'xgboost': 1.5, 'random_forest': 1.4, 'llm': 0.5
            },
            'group4': {
                'freq': 1.2, 'rsi': 0.8, 'slope': 1.0, 'knn': 0.9,
                'svm': 1.1, 'markov': 1.3, 'pca': 0.7,
                'xgboost': 1.5, 'random_forest': 1.4, 'llm': 0.5
            }
        }
        
        logger.info("å››ç¾¤åˆ†å€ç­–ç•¥å¼•æ“å·²åˆå§‹åŒ–")
        logger.info(f"ç¾¤çµ„å®šç¾©: {self.GROUPS}")
    
    def analyze_group(self, feature_engine, group_id, llm_advice=None, use_enhanced=False):
        """
        åˆ†æå–®ä¸€ç¾¤çµ„,é¸å‡º 0-3 é¡†è™Ÿç¢¼
        
        Args:
            feature_engine: ç‰¹å¾µå¼•æ“ (å·²è¨ˆç®—å¥½æ‰€æœ‰æ¨¡å‹è©•åˆ†)
            group_id: ç¾¤çµ„ ID (group1-4)
            llm_advice: LLM å»ºè­° (å¯é¸)
            use_enhanced: æ˜¯å¦ä½¿ç”¨å¢å¼·æ¨¡å‹
        
        Returns:
            dict: {
                'selected_numbers': [5, 8],
                'scores': {5: 0.88, 8: 0.75, ...},
                'model_scores': {'freq': {...}, 'rsi': {...}, ...}
            }
        """
        group_range = self.GROUPS[group_id]
        group_numbers = list(range(group_range[0], group_range[1] + 1))
        
        # å–å¾—è©²ç¾¤çµ„çš„æ‰€æœ‰æ¨¡å‹è©•åˆ†
        all_scores = feature_engine.get_all_scores(use_enhanced=use_enhanced)
        
        # ç¯©é¸å‡ºè©²ç¾¤çµ„çš„è™Ÿç¢¼
        group_scores = all_scores.loc[all_scores.index.isin(group_numbers)]
        
        # è¨ˆç®—å„æ¨¡å‹çš„åŠ æ¬Šè©•åˆ†
        model_scores = {}
        model_names = ['freq', 'rsi', 'slope', 'knn', 'svm', 'markov', 'pca']
        
        # å¦‚æœä½¿ç”¨å¢å¼·æ¨¡å‹,åŠ å…¥æ–°æ¨¡å‹
        if use_enhanced and 'xgboost' in all_scores.columns:
            model_names.extend(['xgboost', 'random_forest'])
        
        for model_name in model_names:
            if model_name in group_scores.columns:
                model_scores[model_name] = group_scores[model_name].to_dict()
        
        # è¨ˆç®—ç¶œåˆè©•åˆ†
        weighted_scores = self._calculate_weighted_scores(
            group_scores, 
            self.group_weights[group_id],
            llm_advice,
            model_names
        )
        
        # é¸å‡º 0-3 é¡†è™Ÿç¢¼ (å‹•æ…‹é¸æ“‡)
        selected_numbers = self._select_top_numbers(weighted_scores, max_count=3)
        
        return {
            'selected_numbers': selected_numbers,
            'scores': weighted_scores,
            'model_scores': model_scores
        }
    
    def _calculate_weighted_scores(self, scores_df, weights, llm_advice=None, model_names=None):
        """è¨ˆç®—åŠ æ¬Šç¶œåˆè©•åˆ†"""
        if model_names is None:
            model_names = ['freq', 'rsi', 'slope', 'knn', 'svm', 'markov', 'pca']
        
        weighted = pd.Series(0.0, index=scores_df.index)
        total_weight = 0
        
        # æ¨¡å‹åŠ æ¬Š
        for model_name in model_names:
            if model_name == 'llm':
                continue  # LLM å–®ç¨è™•ç†
            
            weight = weights.get(model_name, 1.0)  # å¦‚æœæ¬Šé‡ä¸å­˜åœ¨,ä½¿ç”¨é è¨­å€¼ 1.0
            
            if model_name in scores_df.columns:
                weighted += scores_df[model_name] * weight
                total_weight += weight
        
        # æ­£è¦åŒ–
        if total_weight > 0:
            weighted = weighted / total_weight
        
        # åŠ å…¥ LLM å»ºè­° (å¦‚æœæœ‰)
        if llm_advice and 'numbers' in llm_advice:
            llm_weight = weights.get('llm', 0.5)
            llm_confidence = llm_advice.get('confidence', 0.5)
            
            for num in llm_advice['numbers']:
                if num in weighted.index:
                    # LLM å»ºè­°çš„è™Ÿç¢¼åŠ åˆ†
                    weighted[num] += llm_weight * llm_confidence
        
        return weighted.to_dict()
    
    def _select_top_numbers(self, scores, max_count=3, threshold=0.45, min_count=1):  # ğŸ”¥ 0.6 â†’ 0.45
        """
        å‹•æ…‹é¸æ“‡è™Ÿç¢¼ (1-3 é¡†) - ç¢ºä¿è‡³å°‘é¸å‡º min_count é¡†
        
        Args:
            scores: è©•åˆ†å­—å…¸ {num: score}
            max_count: æœ€å¤šé¸å¹¾é¡†
            threshold: æœ€ä½åˆ†æ•¸é–¾å€¼ (å·²å¾ 0.6 é™è‡³ 0.45)
            min_count: æœ€å°‘é¸å¹¾é¡† (æ–°å¢åƒæ•¸,é è¨­ 1)
        
        Returns:
            list: é¸å‡ºçš„è™Ÿç¢¼
        """
        # æ’åº
        sorted_numbers = sorted(scores.items(), key=lambda x: x[1], reverse=True)
        
        # é¸å‡ºé«˜æ–¼é–¾å€¼ä¸”ä¸è¶…é max_count çš„è™Ÿç¢¼
        selected = []
        for num, score in sorted_numbers:
            if score >= threshold and len(selected) < max_count:
                selected.append(num)
        
        # ğŸ”¥ å¼·åŒ–ä¿®è£œ 3: ç¢ºä¿è‡³å°‘é¸å‡º min_count é¡†,é¿å…ç¾¤çµ„ç©ºç™½
        if len(selected) < min_count and sorted_numbers:
            # å¦‚æœæ²’æœ‰é”åˆ°æœ€å°æ•¸é‡,é¸æ“‡è©•åˆ†æœ€é«˜çš„è™Ÿç¢¼
            for num, score in sorted_numbers:
                if num not in selected:
                    selected.append(num)
                    if len(selected) >= min_count:
                        break
        
        return sorted(selected)
    
    def cross_group_selection(self, group_results, target_count=(6, 9)):
        """
        è·¨ç¾¤ç¯©é¸,å¾å„ç¾¤å€™é¸è™Ÿç¢¼ä¸­é¸å‡ºæœ€çµ‚ 6-9 é¡†
        
        Args:
            group_results: å„ç¾¤åˆ†æçµæœ
            target_count: ç›®æ¨™æ•¸é‡ç¯„åœ (min, max)
        
        Returns:
            dict: {
                'final_selection': [5, 8, 15, ...],
                'selection_scores': {5: 0.88, ...}
            }
        """
        # æ”¶é›†æ‰€æœ‰å€™é¸è™Ÿç¢¼èˆ‡è©•åˆ†
        all_candidates = {}
        
        for group_id, result in group_results.items():
            for num in result['selected_numbers']:
                all_candidates[num] = result['scores'][num]
        
        # æ’åº
        sorted_candidates = sorted(all_candidates.items(), key=lambda x: x[1], reverse=True)
        
        # é¸å‡º target_count ç¯„åœå…§çš„è™Ÿç¢¼
        min_count, max_count = target_count
        
        # è‡³å°‘é¸ min_count é¡†
        final_selection = [num for num, score in sorted_candidates[:max_count]]
        
        # å¦‚æœå€™é¸æ•¸é‡ä¸è¶³,è‡³å°‘é¸åˆ° min_count
        if len(final_selection) < min_count:
            # å¾å‰©é¤˜è™Ÿç¢¼ä¸­è£œè¶³
            remaining = set(range(1, 40)) - set(final_selection)
            # é€™è£¡å¯ä»¥ç”¨å…¶ä»–ç­–ç•¥è£œè¶³,æš«æ™‚å…ˆéš¨æ©Ÿ
            import random
            additional = random.sample(list(remaining), min_count - len(final_selection))
            final_selection.extend(additional)
        
        return {
            'final_selection': sorted(final_selection),
            'selection_scores': {num: all_candidates.get(num, 0) for num in final_selection}
        }
    
    def update_group_weights(self, group_id, adjustment):
        """
        æ›´æ–°ç¾¤çµ„æ¬Šé‡
        
        Args:
            group_id: ç¾¤çµ„ ID
            adjustment: èª¿æ•´å¹…åº¦ (ä¾‹å¦‚ 0.05 è¡¨ç¤º +5%)
        """
        if group_id not in self.group_weights:
            logger.warning(f"ç¾¤çµ„ {group_id} ä¸å­˜åœ¨")
            return
        
        # å°æ‰€æœ‰æ¨¡å‹æ¬Šé‡é€²è¡Œèª¿æ•´
        for model_name in self.group_weights[group_id]:
            self.group_weights[group_id][model_name] *= (1 + adjustment)
        
        logger.info(f"{group_id} æ¬Šé‡å·²èª¿æ•´ {adjustment:+.0%}")

if __name__ == "__main__":
    # æ¸¬è©¦
    from src.models import FeatureEngine
    
    logger.section("æ¸¬è©¦å››ç¾¤åˆ†å€ç­–ç•¥")
    
    # å»ºç«‹ç‰¹å¾µå¼•æ“
    eng = FeatureEngine()
    scores = eng.get_all_scores()
    
    # å»ºç«‹ç­–ç•¥å¼•æ“
    strategy = GroupBasedStrategy()
    
    # æ¸¬è©¦å„ç¾¤åˆ†æ
    group_results = {}
    for group_id in strategy.GROUPS.keys():
        result = strategy.analyze_group(eng, group_id)
        group_results[group_id] = result
        
        logger.info(f"\n{group_id} çµæœ:")
        logger.info(f"  é¸å‡ºè™Ÿç¢¼: {result['selected_numbers']}")
    
    # æ¸¬è©¦è·¨ç¾¤ç¯©é¸
    final_result = strategy.cross_group_selection(group_results)
    logger.info(f"\næœ€çµ‚é¸å‡º: {final_result['final_selection']}")
