"""
æ™ºèƒ½æ¬Šé‡å„ªåŒ–å™¨
å¯¦ä½œæ¼¸é€²å¼æ¬Šé‡èª¿æ•´èˆ‡æ­·å²é©—è­‰æ©Ÿåˆ¶,é¿å…éåº¦æ“¬åˆ
"""
import numpy as np
from src.logger import logger

class WeightOptimizer:
    """æ™ºèƒ½æ¬Šé‡å„ªåŒ–å™¨"""
    
    def __init__(self, learning_rate=0.6, observation_window=3):
        """
        åˆå§‹åŒ–
        
        Args:
            learning_rate: å­¸ç¿’ç‡ (0-1),æ±ºå®šæ¯æ¬¡èª¿æ•´çš„å¹…åº¦æ¯”ä¾‹
            observation_window: è§€å¯Ÿçª—å£,é€£çºŒå¹¾æœŸä½å‘½ä¸­ç‡æ‰èª¿æ•´
        """
        self.learning_rate = learning_rate
        self.observation_window = observation_window
        self.history = []  # è¨˜éŒ„æ­·å²è¡¨ç¾
        
        logger.info(f"æ™ºèƒ½æ¬Šé‡å„ªåŒ–å™¨å·²åˆå§‹åŒ– (å­¸ç¿’ç‡: {learning_rate}, è§€å¯Ÿçª—å£: {observation_window})")
    
    def should_adjust(self, group_id, accuracy, recent_history):
        """
        åˆ¤æ–·æ˜¯å¦æ‡‰è©²èª¿æ•´æ¬Šé‡
        
        Args:
            group_id: ç¾¤çµ„ ID
            accuracy: æœ¬æ¬¡å‘½ä¸­ç‡
            recent_history: æœ€è¿‘å¹¾æœŸçš„è¡¨ç¾è¨˜éŒ„
        
        Returns:
            dict: {
                'should_adjust': True/False,
                'reason': '...',
                'is_exception': True/False
            }
        """
        # è¦å‰‡ 1: å‘½ä¸­ç‡å¤ªä½,ä½†å¯èƒ½æ˜¯ä¾‹å¤–
        if accuracy < 0.2:
            # æª¢æŸ¥æœ€è¿‘å¹¾æœŸæ˜¯å¦éƒ½å¾ˆä½
            recent_accuracies = [h.get('accuracy', 0) for h in recent_history[-self.observation_window:]]
            
            # ğŸ”¥ å¼·åŒ–ä¿®è£œ 1: é™ä½è³‡æ–™éœ€æ±‚é–€æª»,æ›´å¿«é–‹å§‹èª¿æ•´
            if len(recent_accuracies) < 2:  # åŸæœ¬: self.observation_window
                # è³‡æ–™ä¸è¶³ä½†ä»å˜—è©¦æ¢ç´¢æ€§èª¿æ•´
                return {
                    'should_adjust': True,  # åŸæœ¬: False
                    'reason': f'è³‡æ–™ä¸è¶³ä½†å˜—è©¦æ¢ç´¢æ€§èª¿æ•´ ({len(recent_accuracies)}æœŸ)',
                    'is_exception': False  # åŸæœ¬: True
                }
            
            avg_recent = np.mean(recent_accuracies)
            
            # ğŸ”¥ å¼·åŒ–ä¿®è£œ 2: ç§»é™¤ã€Œæš«ä¸èª¿æ•´ã€é‚è¼¯,æ”¹ç‚ºåˆ†ç´šèª¿æ•´
            if avg_recent < 0.15:
                # æ¥µåº¦ä½è¿·,å¤§å¹…èª¿æ•´
                return {
                    'should_adjust': True,
                    'reason': f'é€£çºŒæ¥µåº¦ä½è¿· (å¹³å‡ {avg_recent:.0%}),å¤§å¹…èª¿æ•´',
                    'is_exception': False
                }
            elif avg_recent < 0.25:
                # æŒçºŒä½è¿·,ä¸­å¹…èª¿æ•´ (åŸæœ¬é€™è£¡æœƒè¿”å› False!)
                return {
                    'should_adjust': True,  # ğŸ”¥ é—œéµä¿®æ”¹: False â†’ True
                    'reason': f'æŒçºŒä½è¿· (å¹³å‡ {avg_recent:.0%}),ä¸­å¹…èª¿æ•´',
                    'is_exception': False
                }
            else:
                # å¯èƒ½æ˜¯ä¾‹å¤–,å°å¹…æ¢ç´¢æ€§èª¿æ•´
                return {
                    'should_adjust': True,  # ğŸ”¥ é—œéµä¿®æ”¹: False â†’ True
                    'reason': f'å°å¹…æ¢ç´¢æ€§èª¿æ•´ (è¿‘æœŸå¹³å‡ {avg_recent:.0%})',
                    'is_exception': False
                }

        
        # è¦å‰‡ 2: å‘½ä¸­ç‡ä¸­ç­‰,å°å¹…èª¿æ•´
        elif 0.2 <= accuracy < 0.4:
            return {
                'should_adjust': True,
                'reason': f'è¡¨ç¾ä¸€èˆ¬ ({accuracy:.0%}),å°å¹…èª¿æ•´',
                'is_exception': False
            }
        
        # è¦å‰‡ 3: å‘½ä¸­ç‡è‰¯å¥½,ä¸­å¹…èª¿æ•´
        elif 0.4 <= accuracy < 0.6:
            return {
                'should_adjust': True,
                'reason': f'è¡¨ç¾è‰¯å¥½ ({accuracy:.0%}),ä¸­å¹…èª¿æ•´',
                'is_exception': False
            }
        
        # è¦å‰‡ 4: å‘½ä¸­ç‡å„ªç§€,å¤§å¹…èª¿æ•´
        else:
            return {
                'should_adjust': True,
                'reason': f'è¡¨ç¾å„ªç§€ ({accuracy:.0%}),å¤§å¹…èª¿æ•´',
                'is_exception': False
            }
    
    def calculate_adjustment(self, accuracy):
        """
        è¨ˆç®—èª¿æ•´å¹…åº¦
        
        Args:
            accuracy: å‘½ä¸­ç‡
        
        Returns:
            float: èª¿æ•´å¹…åº¦ (ä¾‹å¦‚ 0.05 è¡¨ç¤º +5%)
        """
        # æ ¹æ“šå‘½ä¸­ç‡æ±ºå®šèª¿æ•´æ–¹å‘èˆ‡å¹…åº¦
        if accuracy < 0.2:
            target_adjustment = -0.15  # -15%
        elif accuracy < 0.4:
            target_adjustment = -0.10  # -10%
        elif accuracy < 0.6:
            target_adjustment = 0.20   # +20%
        else:
            target_adjustment = 0.30   # +30%
        
        # æ‡‰ç”¨å­¸ç¿’ç‡ (åªèª¿æ•´ç›®æ¨™çš„ 60%)
        actual_adjustment = target_adjustment * self.learning_rate
        
        return actual_adjustment
    
    def backtest_adjustment(self, proposed_weights, historical_data, group_id):
        """
        å›æ¸¬é©—è­‰èª¿æ•´æ˜¯å¦æœ‰æ•ˆ
        
        Args:
            proposed_weights: æè­°çš„æ–°æ¬Šé‡
            historical_data: æ­·å²è³‡æ–™ (æœ€è¿‘ 10 æœŸ)
            group_id: ç¾¤çµ„ ID
        
        Returns:
            dict: {
                'is_valid': True/False,
                'message': '...',
                'improvement': 0.05
            }
        """
        if len(historical_data) < 5:
            # è³‡æ–™ä¸è¶³,ç„¡æ³•é©—è­‰
            return {
                'is_valid': True,  # é è¨­å…è¨±
                'message': 'æ­·å²è³‡æ–™ä¸è¶³,è·³éé©—è­‰',
                'improvement': 0
            }
        
        try:
            # ç°¡åŒ–ç‰ˆå›æ¸¬:æ¯”è¼ƒæœ€è¿‘ 5 æœŸçš„å¹³å‡å‘½ä¸­ç‡
            recent_5 = historical_data[-5:]
            avg_accuracy = np.mean([h.get('accuracy', 0) for h in recent_5])
            
            # å¦‚æœæœ€è¿‘è¡¨ç¾å·²ç¶“ä¸éŒ¯,èª¿æ•´å¯èƒ½æœ‰æ•ˆ
            if avg_accuracy > 0.3:
                return {
                    'is_valid': True,
                    'message': f'è¿‘æœŸè¡¨ç¾è‰¯å¥½ ({avg_accuracy:.0%}),èª¿æ•´æœ‰æ•ˆ',
                    'improvement': 0.05
                }
            else:
                # è¡¨ç¾ä¸ä½³,èª¿æ•´å¯èƒ½ç„¡æ•ˆ
                return {
                    'is_valid': False,
                    'message': f'è¿‘æœŸè¡¨ç¾ä¸ä½³ ({avg_accuracy:.0%}),æš«ä¸èª¿æ•´',
                    'improvement': 0
                }
        
        except Exception as e:
            logger.error(f"å›æ¸¬é©—è­‰å¤±æ•—: {e}")
            return {
                'is_valid': True,  # éŒ¯èª¤æ™‚é è¨­å…è¨±
                'message': f'é©—è­‰éŒ¯èª¤: {e}',
                'improvement': 0
            }
    
    def optimize_group_weights(self, group_id, accuracy, group_history, current_weights):
        """
        å„ªåŒ–å–®ä¸€ç¾¤çµ„çš„æ¬Šé‡
        
        Args:
            group_id: ç¾¤çµ„ ID
            accuracy: æœ¬æ¬¡å‘½ä¸­ç‡
            group_history: è©²ç¾¤çµ„çš„æ­·å²è¡¨ç¾
            current_weights: ç•¶å‰æ¬Šé‡
        
        Returns:
            dict: {
                'action': 'adjust'/'maintain',
                'adjustment': 0.05,
                'new_weights': {...},
                'reason': '...'
            }
        """
        # åˆ¤æ–·æ˜¯å¦èª¿æ•´
        decision = self.should_adjust(group_id, accuracy, group_history)
        
        if not decision['should_adjust']:
            return {
                'action': 'maintain',
                'adjustment': 0,
                'new_weights': current_weights,
                'reason': decision['reason']
            }
        
        # è¨ˆç®—èª¿æ•´å¹…åº¦
        adjustment = self.calculate_adjustment(accuracy)
        
        # å›æ¸¬é©—è­‰
        backtest_result = self.backtest_adjustment(
            current_weights,
            group_history,
            group_id
        )
        
        if not backtest_result['is_valid']:
            return {
                'action': 'maintain',
                'adjustment': 0,
                'new_weights': current_weights,
                'reason': backtest_result['message'],
                'backtest': backtest_result
            }
        
        # åŸ·è¡Œèª¿æ•´
        new_weights = {}
        for model_name, weight in current_weights.items():
            new_weights[model_name] = weight * (1 + adjustment)
        
        return {
            'action': 'adjust',
            'adjustment': adjustment,
            'new_weights': new_weights,
            'reason': decision['reason'],
            'backtest': backtest_result
        }

if __name__ == "__main__":
    # æ¸¬è©¦
    optimizer = WeightOptimizer(learning_rate=0.6, observation_window=3)
    
    # æ¨¡æ“¬æ­·å²è³‡æ–™
    test_history = [
        {'accuracy': 0.2},
        {'accuracy': 0.4},
        {'accuracy': 0.6}
    ]
    
    test_weights = {
        'freq': 1.0,
        'rsi': 1.0,
        'slope': 1.0
    }
    
    # æ¸¬è©¦å„ªåŒ–
    result = optimizer.optimize_group_weights(
        'group1',
        0.6,  # 60% å‘½ä¸­ç‡
        test_history,
        test_weights
    )
    
    logger.info(f"å„ªåŒ–çµæœ: {result}")
